#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>  // ç”¨äºè¯»å–ç›®å½•å†…å®¹
#include <termios.h> // ç”¨äºå¤„ç†ç»ˆç«¯è®¾ç½®
#include <ctype.h>   // ç”¨äºå­—ç¬¦å¤„ç†
#include <time.h>    // ç”¨äºå»¶æ—¶åŠŸèƒ½
#include <linux/input.h>
#include <math.h>
#include <pthread.h> // ç”¨äºå¤šçº¿ç¨‹

#define WHITE 0xffffff

// å±å¹•å®½åº¦å’Œé«˜åº¦
#define WIDTH 800
#define HEIGHT 480

// æœ€å¤§BMPæ–‡ä»¶æ•°é‡
#define MAX_BMP_FILES 100

// ç‚¹å‡»åŒºåŸŸå®šä¹‰
#define LEFT_CLICK_AREA (WIDTH / 3)      // å·¦ä¾§1/3åŒºåŸŸä¸ºä¸Šä¸€å¼ 
#define RIGHT_CLICK_AREA (WIDTH * 2 / 3) // å³ä¾§1/3åŒºåŸŸä¸ºä¸‹ä¸€å¼ 

// å…¨å±€å˜é‡
int refresh_delay = 5;                                     // è¡Œåˆ·æ–°å»¶è¿Ÿæ—¶é—´(æ¯«ç§’)
int use_slow_refresh = 1;                                  // æ˜¯å¦ä½¿ç”¨é€è¡Œåˆ·æ–°æ¨¡å¼
int current_index = 0;                                     // å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡ç´¢å¼•
int bmp_count = 0;                                         // BMPæ–‡ä»¶æ€»æ•°
char bmp_files[MAX_BMP_FILES][256] = {0};                  // BMPæ–‡ä»¶åˆ—è¡¨
int *map_addr = NULL;                                      // LCDå†…å­˜æ˜ å°„åœ°å€
int screen_w = WIDTH;                                      // å±å¹•å®½åº¦
int screen_h = HEIGHT;                                     // å±å¹•é«˜åº¦
int need_refresh = 0;                                      // æ˜¯å¦éœ€è¦åˆ·æ–°å›¾ç‰‡
pthread_mutex_t refresh_mutex = PTHREAD_MUTEX_INITIALIZER; // åˆ·æ–°äº’æ–¥é”

// æ¯«ç§’çº§å»¶æ—¶å‡½æ•°
void delay_ms(int milliseconds)
{
    struct timespec ts;
    ts.tv_sec = milliseconds / 1000;
    ts.tv_nsec = (milliseconds % 1000) * 1000000;
    nanosleep(&ts, NULL);
}

// è·å–å­—ç¬¦å‡½æ•°ï¼ˆæ— ç¼“å†²è¾“å…¥ï¼‰
int getch(void)
{
    struct termios old_settings, new_settings;
    int ch;

    tcgetattr(STDIN_FILENO, &old_settings);
    new_settings = old_settings;
    new_settings.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &new_settings);
    ch = getchar();
    tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);

    return ch;
}

// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºBMPæ ¼å¼
int is_bmp_file(const char *filename)
{
    const char *ext = strrchr(filename, '.');
    if (ext && strcasecmp(ext, ".bmp") == 0)
    {
        return 1;
    }
    return 0;
}

// BMPæ–‡ä»¶å¤´
struct bitmap_header
{
    int16_t type;          // æ–‡ä»¶ç±»å‹    2
    int32_t size;          // å›¾åƒæ–‡ä»¶å¤§å° 4
    int16_t reserved1;     // ä¿ç•™        2
    int16_t reserved2;     // ä¿ç•™        2
    int32_t offbits;       // bmpå›¾åƒæ•°æ®åç§»é‡ 4
} __attribute__((packed)); // ä¸å¯¹é½å­—èŠ‚,æ ¹æ®æ•°æ®å¤§å°åˆ†é…

// BMPä¿¡æ¯å¤´
struct bitmap_info
{
    int32_t size;   // æœ¬ç»“æ„ä½“çš„å¤§å°
    int32_t width;  // å›¾åƒå®½ ğŸ‘
    int32_t height; // å›¾åƒé«˜ ğŸ‘
    int16_t planes;

    int16_t bit_count; // è‰²æ·± ğŸ‘
    int32_t compression;
    int32_t size_img; // bmpæ•°æ®å¤§å°ï¼Œå¿…é¡»æ˜¯4çš„æ•´æ•°å€
    int32_t X_pel;
    int32_t Y_pel;
    int32_t clrused;
    int32_t clrImportant;
} __attribute__((packed));

// æ˜¾ç¤ºBMPå›¾ç‰‡åˆ°LCDå±å¹•
int display_bmp(const char *filename, int *map_addr, int screen_w, int screen_h)
{
    // 1. æ‰“å¼€å¹¶è¯»å–BMPæ–‡ä»¶ä¿¡æ¯
    FILE *fp = fopen(filename, "r");
    if (fp == NULL)
    {
        perror("æ‰“å¼€å›¾ç‰‡å¤±è´¥");
        return -1;
    }

    struct bitmap_header head = {0};
    if (fread(&head, sizeof(head), 1, fp) != 1)
    {
        perror("è¯»å–BMPæ–‡ä»¶å¤´å¤±è´¥");
        fclose(fp);
        return -1;
    }

    if (head.type != 0x4D42)
    { // 'BM'
        fprintf(stderr, "ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„BMPæ–‡ä»¶\n");
        fclose(fp);
        return -1;
    }

    struct bitmap_info info = {0};
    if (fread(&info, sizeof(info), 1, fp) != 1)
    {
        perror("è¯»å–BMPä¿¡æ¯å¤´å¤±è´¥");
        fclose(fp);
        return -1;
    }

    printf("å›¾ç‰‡ä¿¡æ¯: %s\n", filename);
    printf("å®½åº¦: %d, é«˜åº¦: %d, è‰²æ·±: %d\n", info.width, info.height, info.bit_count);

    if (info.bit_count != 24 && info.bit_count != 32)
    {
        fprintf(stderr, "ä¸æ”¯æŒçš„è‰²æ·±: %d, åªæ”¯æŒ24ä½å’Œ32ä½\n", info.bit_count);
        fclose(fp);
        return -1;
    }

    // 2. è¯»å–BMPåƒç´ æ•°æ®
    int bytes_per_pixel = info.bit_count / 8;
    int row_size = ((info.width * bytes_per_pixel + 3) / 4) * 4; // 4å­—èŠ‚å¯¹é½çš„è¡Œå¤§å°
    int image_size = row_size * abs(info.height);

    char *bgr_buf = malloc(image_size);
    if (bgr_buf == NULL)
    {
        perror("ä¸ºBMPæ•°æ®åˆ†é…å†…å­˜å¤±è´¥");
        fclose(fp);
        return -1;
    }

    fseek(fp, head.offbits, SEEK_SET);
    if (fread(bgr_buf, 1, image_size, fp) != image_size)
    {
        perror("è¯»å–BMPåƒç´ æ•°æ®å¤±è´¥");
        free(bgr_buf);
        fclose(fp);
        return -1;
    }
    fclose(fp);

    // 3. è½¬æ¢åƒç´ å¹¶å†™å…¥å±å¹•å†…å­˜
    int w = info.width;
    int h = abs(info.height);

    // ç¡®å®šè¦ç»˜åˆ¶çš„åŒºåŸŸå¤§å°ï¼ˆé˜²æ­¢å›¾ç‰‡è¶…å‡ºå±å¹•ï¼‰
    int draw_w = (w < screen_w) ? w : screen_w;
    int draw_h = (h < screen_h) ? h : screen_h;

    // æ¸…å±ä¸ºé»‘è‰²
    memset(map_addr, 0, screen_w * screen_h * sizeof(int));

    // æ ¹æ®æ¨¡å¼é€‰æ‹©æ˜¾ç¤ºæ–¹å¼
    if (use_slow_refresh)
    {
        printf("æ­£åœ¨é€è¡ŒåŠ è½½å›¾ç‰‡...\n");

        // é€è¡Œæ˜¾ç¤ºå›¾ç‰‡ï¼Œå¹¶æ·»åŠ å»¶è¿Ÿ
        for (int y = 0; y < draw_h; y++)
        {
            for (int x = 0; x < draw_w; x++)
            {
                int bmp_y = (info.height > 0) ? (h - 1 - y) : y; // å¤„ç†å‚ç›´ç¿»è½¬
                char *src_pixel = bgr_buf + bmp_y * row_size + x * bytes_per_pixel;
                int *dst_pixel = map_addr + y * screen_w + x;

                // å°†BGR(A)è½¬æ¢ä¸ºARGB
                char b = src_pixel[0];
                char g = src_pixel[1];
                char r = src_pixel[2];
                *dst_pixel = (0 << 24) | (r << 16) | (g << 8) | b;
            }

            // æ¯æ˜¾ç¤ºä¸€è¡Œåå»¶è¿Ÿ
            if (refresh_delay > 0)
            {
                delay_ms(refresh_delay);
            }

            // æ¯10è¡Œè¾“å‡ºä¸€æ¬¡è¿›åº¦
            if (y % 10 == 0 || y == draw_h - 1)
            {
                printf("\råŠ è½½è¿›åº¦: %.1f%%", (float)(y + 1) * 100 / draw_h);
                fflush(stdout);
            }
        }
        printf("\nå›¾ç‰‡åŠ è½½å®Œæˆ!\n");
    }
    else
    {
        // ç›´æ¥æ˜¾ç¤ºæ•´å¼ å›¾ç‰‡ï¼ˆæ— å»¶è¿Ÿï¼‰
        printf("ç›´æ¥åŠ è½½æ•´å¼ å›¾ç‰‡...\n");
        for (int y = 0; y < draw_h; y++)
        {
            for (int x = 0; x < draw_w; x++)
            {
                int bmp_y = (info.height > 0) ? (h - 1 - y) : y; // å¤„ç†å‚ç›´ç¿»è½¬
                char *src_pixel = bgr_buf + bmp_y * row_size + x * bytes_per_pixel;
                int *dst_pixel = map_addr + y * screen_w + x;

                // å°†BGR(A)è½¬æ¢ä¸ºARGB
                char b = src_pixel[0];
                char g = src_pixel[1];
                char r = src_pixel[2];
                *dst_pixel = (0 << 24) | (r << 16) | (g << 8) | b;
            }
        }
        printf("å›¾ç‰‡åŠ è½½å®Œæˆ!\n");
    }

    free(bgr_buf);
    return 0;
}

// æ˜¾ç¤ºä¸‹ä¸€å¼ å›¾ç‰‡
void show_next_image()
{
    pthread_mutex_lock(&refresh_mutex);
    current_index = (current_index + 1) % bmp_count;
    printf("æ˜¾ç¤ºä¸‹ä¸€å¼ å›¾ç‰‡ (%d/%d): %s\n", current_index + 1, bmp_count, bmp_files[current_index]);
    if (display_bmp(bmp_files[current_index], map_addr, screen_w, screen_h) < 0)
    {
        printf("æ˜¾ç¤ºå›¾ç‰‡å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€å¼ \n");
    }
    pthread_mutex_unlock(&refresh_mutex);
}

// æ˜¾ç¤ºä¸Šä¸€å¼ å›¾ç‰‡
void show_prev_image()
{
    pthread_mutex_lock(&refresh_mutex);
    current_index = (current_index - 1 + bmp_count) % bmp_count;
    printf("æ˜¾ç¤ºä¸Šä¸€å¼ å›¾ç‰‡ (%d/%d): %s\n", current_index + 1, bmp_count, bmp_files[current_index]);
    if (display_bmp(bmp_files[current_index], map_addr, screen_w, screen_h) < 0)
    {
        printf("æ˜¾ç¤ºå›¾ç‰‡å¤±è´¥ï¼Œå°è¯•ä¸Šä¸€å¼ \n");
    }
    pthread_mutex_unlock(&refresh_mutex);
}

// åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
void toggle_refresh_mode()
{
    pthread_mutex_lock(&refresh_mutex);
    use_slow_refresh = !use_slow_refresh;
    printf("åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼ä¸º: %s\n", use_slow_refresh ? "é€è¡Œæ˜¾ç¤º" : "å¿«é€Ÿæ˜¾ç¤º");
    printf("é‡æ–°åŠ è½½å›¾ç‰‡ä»¥åº”ç”¨æ–°è®¾ç½®...\n");
    if (display_bmp(bmp_files[current_index], map_addr, screen_w, screen_h) < 0)
    {
        printf("é‡æ–°åŠ è½½å›¾ç‰‡å¤±è´¥\n");
    }
    pthread_mutex_unlock(&refresh_mutex);
}

// è§¦æ‘¸å±å¤„ç†çº¿ç¨‹
void *touch_handler(void *arg)
{
    // æ‰“å¼€è§¦æ‘¸å±è®¾å¤‡
    int fd = open("/dev/input/event0", O_RDONLY);
    if (fd < 0)
    {
        perror("æ‰“å¼€è§¦æ‘¸å±è®¾å¤‡å¤±è´¥");
        return NULL;
    }

    struct input_event event;
    int touch_start_x = 0, touch_start_y = 0; // è§¦æ‘¸å¼€å§‹æ—¶çš„åæ ‡
    int current_x = 0, current_y = 0;         // å½“å‰åæ ‡
    int touch_pressed = 0;                    // è§¦æ‘¸çŠ¶æ€æ ‡å¿—

    printf("è§¦æ‘¸å±å¤„ç†çº¿ç¨‹å·²å¯åŠ¨\n");

    while (1)
    {
        int ret = read(fd, &event, sizeof(event));
        if (ret < 0)
        {
            perror("è¯»å–è§¦æ‘¸äº‹ä»¶å¤±è´¥");
            break;
        }

        // å¤„ç†è¾“å…¥æ¨¡å‹æ•°æ®
        if (event.type == EV_ABS && event.code == ABS_X)
        {
            current_x = event.value * 800 / 1024;
        }
        else if (event.type == EV_ABS && event.code == ABS_Y)
        {
            current_y = event.value * 480 / 600;
        }
        else if (event.type == EV_KEY && event.code == BTN_TOUCH)
        {
            if (event.value == 1)
            {
                printf("è§¦æ‘¸å±è¢«è§¦æ‘¸åœ¨åæ ‡: (%d, %d)\n", current_x, current_y);
                touch_start_x = current_x;
                touch_start_y = current_y;
                touch_pressed = 1;
            }
            else if (event.value == 0)
            {
                printf("è§¦æ‘¸å±é‡Šæ”¾\n");
                printf("èµ·å§‹åæ ‡: (%d, %d), ç»“æŸåæ ‡: (%d, %d)\n",
                       touch_start_x, touch_start_y, current_x, current_y);

                // è®¡ç®—æ»‘åŠ¨è·ç¦»
                int dx = current_x - touch_start_x;
                int dy = current_y - touch_start_y;

                // åˆ¤æ–­æ˜¯æ»‘åŠ¨è¿˜æ˜¯ç‚¹å‡»
                if (abs(dx) > 100 || abs(dy) > 100)
                {
                    // æ»‘åŠ¨æ“ä½œ
                    if (abs(dx) > abs(dy))
                    {
                        // æ°´å¹³æ»‘åŠ¨
                        if (dx > 100)
                        {
                            printf("è§¦æ‘¸å±å‘å³æ»‘åŠ¨ - æ˜¾ç¤ºä¸Šä¸€å¼ å›¾ç‰‡\n");
                            show_prev_image();
                        }
                        else if (dx < -100)
                        {
                            printf("è§¦æ‘¸å±å‘å·¦æ»‘åŠ¨ - æ˜¾ç¤ºä¸‹ä¸€å¼ å›¾ç‰‡\n");
                            show_next_image();
                        }
                    }
                    else
                    {
                        // å‚ç›´æ»‘åŠ¨ - åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
                        if (abs(dy) > 100)
                        {
                            printf("è§¦æ‘¸å±ä¸Šä¸‹æ»‘åŠ¨ - åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼\n");
                            toggle_refresh_mode();
                        }
                    }
                }
                else
                {
                    // ç‚¹å‡»æ“ä½œ
                    if (touch_start_x < LEFT_CLICK_AREA)
                    {
                        printf("ç‚¹å‡»å±å¹•å·¦ä¾§ - æ˜¾ç¤ºä¸Šä¸€å¼ å›¾ç‰‡\n");
                        show_prev_image();
                    }
                    else if (touch_start_x > RIGHT_CLICK_AREA)
                    {
                        printf("ç‚¹å‡»å±å¹•å³ä¾§ - æ˜¾ç¤ºä¸‹ä¸€å¼ å›¾ç‰‡\n");
                        show_next_image();
                    }
                    else
                    {
                        printf("ç‚¹å‡»å±å¹•ä¸­é—´åŒºåŸŸ\n");
                        // ä¸­é—´åŒºåŸŸå¯ä»¥ç”¨äºå…¶ä»–åŠŸèƒ½ï¼Œæ¯”å¦‚æ˜¾ç¤ºä¿¡æ¯
                    }
                }
                touch_pressed = 0;
            }
        }
    }

    close(fd);
    return NULL;
}

int main()
{
    // 1. æ‰«æå½“å‰ç›®å½•ä¸‹çš„æ‰€æœ‰BMPæ–‡ä»¶
    DIR *dir;
    struct dirent *entry;

    dir = opendir(".");
    if (!dir)
    {
        perror("æ— æ³•æ‰“å¼€å½“å‰ç›®å½•");
        return -1;
    }

    printf("æ‰«æå½“å‰ç›®å½•çš„BMPæ–‡ä»¶...\n");
    while ((entry = readdir(dir)) != NULL && bmp_count < MAX_BMP_FILES)
    {
        if (is_bmp_file(entry->d_name))
        {
            strncpy(bmp_files[bmp_count], entry->d_name, 255);
            bmp_files[bmp_count][255] = '\0'; // ç¡®ä¿å­—ç¬¦ä¸²ç»“æŸ
            printf("æ‰¾åˆ°BMPæ–‡ä»¶: %s\n", bmp_files[bmp_count]);
            bmp_count++;
        }
    }
    closedir(dir);

    if (bmp_count == 0)
    {
        printf("å½“å‰ç›®å½•ä¸‹æ²¡æœ‰æ‰¾åˆ°ä»»ä½•BMPæ–‡ä»¶\n");
        return -1;
    }

    printf("å…±æ‰¾åˆ° %d ä¸ªBMPæ–‡ä»¶\n", bmp_count);

    // 2. æ‰“å¼€å¹¶æ˜ å°„LCDå±å¹•
    int lcd_fd = open("/dev/fb0", O_RDWR);
    if (lcd_fd == -1)
    {
        perror("æ‰“å¼€LCDå¤±è´¥");
        return -1;
    }

    int screen_bpp = 4;
    long screen_size = screen_w * screen_h * screen_bpp;

    map_addr = mmap(NULL, screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, lcd_fd, 0);
    if (map_addr == MAP_FAILED)
    {
        perror("æ˜ å°„LCDå†…å­˜å¤±è´¥");
        close(lcd_fd);
        return -1;
    }

    // 3. æ˜¾ç¤ºç¬¬ä¸€å¼ å›¾ç‰‡
    current_index = 0;
    if (display_bmp(bmp_files[current_index], map_addr, screen_w, screen_h) < 0)
    {
        printf("æ˜¾ç¤ºåˆå§‹å›¾ç‰‡å¤±è´¥\n");
    }

    // 4. å¯åŠ¨è§¦æ‘¸å±å¤„ç†çº¿ç¨‹
    pthread_t touch_thread;
    if (pthread_create(&touch_thread, NULL, touch_handler, NULL) != 0)
    {
        perror("åˆ›å»ºè§¦æ‘¸å±å¤„ç†çº¿ç¨‹å¤±è´¥");
        munmap(map_addr, screen_size);
        close(lcd_fd);
        return -1;
    }

    // 5. ä¸»å¾ªç¯ - å¤„ç†é”®ç›˜è¾“å…¥
    printf("\n");
    printf("======== æ§åˆ¶è¯´æ˜ ========\n");
    printf("é”®ç›˜æ§åˆ¶:\n");
    printf("  n/N: ä¸‹ä¸€å¼ å›¾ç‰‡\n");
    printf("  p/P: ä¸Šä¸€å¼ å›¾ç‰‡\n");
    printf("  +: å¢åŠ åˆ·æ–°å»¶è¿Ÿï¼ˆæ˜¾ç¤ºå˜æ…¢ï¼‰\n");
    printf("  -: å‡å°‘åˆ·æ–°å»¶è¿Ÿï¼ˆæ˜¾ç¤ºå˜å¿«ï¼‰\n");
    printf("  0-9: ç›´æ¥è®¾ç½®åˆ·æ–°é€Ÿåº¦ï¼ˆ0æœ€å¿«ï¼Œ9æœ€æ…¢ï¼‰\n");
    printf("  s/S: åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼ï¼ˆ%sï¼‰\n", use_slow_refresh ? "å½“å‰:é€è¡Œæ˜¾ç¤º" : "å½“å‰:å¿«é€Ÿæ˜¾ç¤º");
    printf("  r/R: é‡æ–°åŠ è½½å½“å‰å›¾ç‰‡\n");
    printf("  q/Q/ESC: é€€å‡ºç¨‹åº\n");
    printf("è§¦æ‘¸å±æ§åˆ¶:\n");
    printf("  ç‚¹å‡»å·¦ä¾§1/3åŒºåŸŸ: ä¸Šä¸€å¼ å›¾ç‰‡\n");
    printf("  ç‚¹å‡»å³ä¾§1/3åŒºåŸŸ: ä¸‹ä¸€å¼ å›¾ç‰‡\n");
    printf("  å·¦æ»‘: ä¸‹ä¸€å¼ å›¾ç‰‡\n");
    printf("  å³æ»‘: ä¸Šä¸€å¼ å›¾ç‰‡\n");
    printf("  ä¸Šä¸‹æ»‘: åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼\n");
    printf("å½“å‰åˆ·æ–°å»¶è¿Ÿ: %d æ¯«ç§’/è¡Œ\n", refresh_delay);
    printf("========================\n");

    int ch;
    int running = 1;

    while (running)
    {
        ch = getch();

        switch (ch)
        {
        case 'n':
        case 'N':
        case '\n': // å›è½¦é”®
            show_next_image();
            break;

        case 'p':
        case 'P':
            show_prev_image();
            break;

        case 'q':
        case 'Q':
        case 27: // ESCé”®
            printf("é€€å‡ºç¨‹åº\n");
            running = 0;
            break;

        // è°ƒèŠ‚æ˜¾ç¤ºé€Ÿåº¦
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            refresh_delay = (ch - '0') * 10; // è®¾ç½®ä¸ºå¯¹åº”çš„æ¯«ç§’æ•°
            printf("è®¾ç½®è¡Œåˆ·æ–°å»¶è¿Ÿæ—¶é—´ä¸º: %d æ¯«ç§’/è¡Œ\n", refresh_delay);
            break;

        case '+': // å¢åŠ å»¶è¿Ÿï¼ˆå˜æ…¢ï¼‰
            refresh_delay += 5;
            if (refresh_delay > 200)
                refresh_delay = 200; // è®¾ç½®ä¸Šé™
            printf("å¢åŠ å»¶è¿Ÿ - å½“å‰åˆ·æ–°å»¶è¿Ÿ: %d æ¯«ç§’/è¡Œ\n", refresh_delay);
            break;

        case '-': // å‡å°‘å»¶è¿Ÿï¼ˆå˜å¿«ï¼‰
            refresh_delay -= 5;
            if (refresh_delay < 0)
                refresh_delay = 0; // ç¡®ä¿ä¸ä¸ºè´Ÿ
            printf("å‡å°‘å»¶è¿Ÿ - å½“å‰åˆ·æ–°å»¶è¿Ÿ: %d æ¯«ç§’/è¡Œ\n", refresh_delay);
            break;

        case 'r':
        case 'R': // é‡æ–°åŠ è½½å½“å‰å›¾ç‰‡
            printf("é‡æ–°åŠ è½½å›¾ç‰‡: %s\n", bmp_files[current_index]);
            pthread_mutex_lock(&refresh_mutex);
            if (display_bmp(bmp_files[current_index], map_addr, screen_w, screen_h) < 0)
            {
                printf("é‡æ–°åŠ è½½å›¾ç‰‡å¤±è´¥\n");
            }
            pthread_mutex_unlock(&refresh_mutex);
            break;

        case 's':
        case 'S': // åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
            toggle_refresh_mode();
            break;

        default:
            // å¿½ç•¥å…¶ä»–é”®
            break;
        }
    }

    // 6. æ¸…ç†èµ„æº
    // ç­‰å¾…è§¦æ‘¸å±çº¿ç¨‹ç»“æŸï¼ˆå®é™…ä¸Šå®ƒæ˜¯æ— é™å¾ªç¯ï¼Œæ‰€ä»¥è¿™é‡Œä¼šä¸€ç›´ç­‰å¾…ï¼‰
    // pthread_join(touch_thread, NULL);

    munmap(map_addr, screen_size);
    close(lcd_fd);
    pthread_mutex_destroy(&refresh_mutex);

    return 0;
}
